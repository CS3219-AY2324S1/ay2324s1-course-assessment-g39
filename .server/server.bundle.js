(()=>{"use strict";var e={n:t=>{var s=t&&t.__esModule?()=>t.default:()=>t;return e.d(s,{a:s}),s},d:(t,s)=>{for(var r in s)e.o(s,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:s[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=require("zod"),s=require("@trpc/server"),r=require("next-auth/react"),n=require("superjson");var o=e.n(n);const i=require("@next-auth/prisma-adapter"),a=require("next-auth/providers/github");var c=e.n(a);const d=require("bcrypt");var u=e.n(d);require("next-auth");const l=require("next-auth/providers/credentials");var p=e.n(l);const S=(0,require("@t3-oss/env-nextjs").createEnv)({server:{POSTGRES_USER:t.z.string().min(1),POSTGRES_PASSWORD:t.z.string().min(1),POSTGRES_URL:t.z.string().url(),MONGO_USER:t.z.string().min(1),MONGO_PASSWORD:t.z.string().min(1),MONGO_URL:t.z.string().url(),NODE_ENV:t.z.enum(["development","test","production"]),NEXTAUTH_SECRET:t.z.string().min(1),NEXTAUTH_URL:t.z.preprocess((e=>{var t;return null!==(t=process.env.VERCEL_URL)&&void 0!==t?t:e}),process.env.VERCEL?t.z.string().min(1):t.z.string().url()),S3_BUCKET_NAME:t.z.string().min(1),GITHUB_ID:t.z.string().min(1),GITHUB_SECRET:t.z.string().min(1)},client:{NEXT_PUBLIC_WS_PORT:t.z.string().min(1)},runtimeEnv:{POSTGRES_USER:process.env.POSTGRES_USER,POSTGRES_PASSWORD:process.env.POSTGRES_PASSWORD,POSTGRES_URL:process.env.POSTGRES_URL,MONGO_USER:process.env.MONGO_USER,MONGO_PASSWORD:process.env.MONGO_PASSWORD,MONGO_URL:process.env.MONGO_URL,NODE_ENV:"production",NEXTAUTH_SECRET:process.env.NEXTAUTH_SECRET,NEXT_PUBLIC_WS_PORT:process.env.NEXT_PUBLIC_WS_PORT,NEXTAUTH_URL:process.env.NEXTAUTH_URL,S3_BUCKET_NAME:process.env.S3_BUCKET_NAME,GITHUB_ID:process.env.GITHUB_ID,GITHUB_SECRET:process.env.GITHUB_SECRET},skipValidation:!!process.env.SKIP_ENV_VALIDATION}),g=require("@prisma-db-mongo/client"),m=require("@prisma-db-psql/client");var w,f;const{NODE_ENV:h}=S,y=globalThis,E="development"===h?["query","error","warn"]:["error"],I=null!==(w=y.prismaPostgres)&&void 0!==w?w:new m.PrismaClient({log:E}),R=null!==(f=y.prismaMongo)&&void 0!==f?f:new g.PrismaClient({log:E});"production"!==h&&(y.prismaPostgres=I,y.prismaMongo=R);async function v(e){return await u().genSalt(10).then((t=>u().hash(e,t)))}process.env.NEXT_AUTH_SECRET,(0,i.PrismaAdapter)(I),c()({clientId:S.GITHUB_ID,clientSecret:S.GITHUB_SECRET}),p()({name:"Credentials",credentials:{email:{label:"Email",type:"email",placeholder:"jsmith@gmail.com"},password:{label:"Password",type:"password",placeholder:"••••••••"}},async authorize(e,t){var s;if(!(null===(s=t.body)||void 0===s?void 0:s.email)||!t.body.password)return null;const{email:r,password:n}=t.body,o=await I.user.findUnique({where:{email:r}});if(!(null==o?void 0:o.password))return null;if(o&&u().compareSync(n,o.password)){const{password:e}=o;return function(e,t){var s={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(s[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(s[r[n]]=e[r[n]])}return s}(o,["password"])}return null}});const O=async e=>({session:await(0,r.getSession)(e),prismaPostgres:I,prismaMongo:R}),T=s.initTRPC.context().create({transformer:o(),errorFormatter:({shape:e,error:s})=>Object.assign(Object.assign({},e),{data:Object.assign(Object.assign({},e.data),{zodError:s.cause instanceof t.ZodError?s.cause.flatten():null})})}),_=T.router,b=T.procedure,U=T.middleware((({ctx:e,next:t})=>{var r;if(!(null===(r=e.session)||void 0===r?void 0:r.user))throw new s.TRPCError({code:"UNAUTHORIZED"});return t({ctx:{session:Object.assign(Object.assign({},e.session),{user:e.session.user})}})})),q=T.middleware((({ctx:e,next:t})=>{var r,n;if(!(null===(r=e.session)||void 0===r?void 0:r.user)||"MAINTAINER"!==(null===(n=e.session)||void 0===n?void 0:n.user.role))throw new s.TRPCError({code:"UNAUTHORIZED"});return t({ctx:{session:Object.assign(Object.assign({},e.session),{user:e.session.user})}})})),P=T.procedure.use(U),z=T.procedure.use(q);const N=t.z.object({title:t.z.string(),body:t.z.string(),difficulty:t.z.number(),category:t.z.string()}),x=t.z.object({id:t.z.string(),title:t.z.string().optional(),body:t.z.string().optional(),difficulty:t.z.number().optional(),category:t.z.string().optional()}),C=_({getAll:b.query((({ctx:e})=>e.prismaMongo.question.findMany())),addOne:z.input(N).mutation((async({ctx:e,input:t})=>{const s=await e.prismaMongo.question.create({data:Object.assign({},t)});return{message:`Question created: ${t.title}`,id:s.id}})),updateOne:z.input(x).mutation((async({ctx:e,input:t})=>{const{id:s}=t,r=function(e,t){var s={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(s[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(s[r[n]]=e[r[n]])}return s}(t,["id"]);return await e.prismaMongo.question.update({where:{id:s},data:r}),{message:`Question updated: ${t.title}`}})),deleteOne:z.input(t.z.object({id:t.z.string()})).mutation((async({ctx:e,input:t})=>(await e.prismaMongo.question.delete({where:{id:t.id}}),{message:"Question deleted"})))});var j=function(e,t){var s={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(s[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(s[r[n]]=e[r[n]])}return s};const A=t.z.string().min(1),M=t.z.string().min(1),G=t.z.string().email().min(1),B=(t.z.date().nullable(),t.z.string().nullable()),D=t.z.string().min(6),H=t.z.enum(["MAINTAINER","USER"]).nullable(),L=t.z.object({name:M,email:G,password:D,image:B,role:H}),V=t.z.object({id:A,name:M,email:G,image:B}),W=t.z.object({id:A,password:D}),Q=_({create:b.input(L).mutation((async({input:e})=>{const{password:t,role:r}=e,n=j(e,["password","role"]),o=await v(t);try{await I.user.create({data:Object.assign(Object.assign({role:null!=r?r:void 0},n),{password:o})})}catch(e){throw new s.TRPCError({code:"INTERNAL_SERVER_ERROR",message:"An internal error occurred. Please try again later."})}})),deleteUserByID:P.input(t.z.object({id:A})).mutation((async({ctx:e,input:t})=>(await e.prismaPostgres.user.delete({where:{id:t.id}}),{message:"User deleted"}))),update:P.input(V).mutation((async({ctx:e,input:t})=>{const{id:s}=t,r=j(t,["id"]);await e.prismaPostgres.user.update({where:{id:s},data:r})})),updatePassword:P.input(W).mutation((async({ctx:e,input:t})=>{const{id:s,password:r}=t,n=await v(r);await e.prismaPostgres.user.update({where:{id:s},data:{password:n}})}))}),X=require("amqplib/callback_api");var K=e.n(X);const k=t.z.object({difficulty:t.z.number().min(0).max(5),category:t.z.string(),id:t.z.string()});class ${async sendRequest(e){return await new Promise(((t,s)=>{K().connect("amqp://localhost",((r,n)=>{r&&s(r),n.createChannel(((r,n)=>{r&&s(r),n.assertQueue("",{durable:!0},((r,o)=>{r&&s(r),console.log(`[x] Sending match request: '${e.id}' with difficulty: ${e.difficulty} and category: ${e.category}`),n.consume(o.queue,(s=>{s&&s.properties.correlationId===e.id&&(console.log(`[x] Received partner: ${s.properties.headers.partner}.`),console.log(s.content.toString()),t({msg:s.content.toString(),partner:s.properties.headers.partner,isSuccess:s.properties.headers.isSuccess}),setTimeout((()=>{n.close((e=>{if(e)throw e}))}),500))})),n.sendToQueue("request_queue",Buffer.from(""),{persistent:!0,replyTo:o.queue,headers:{difficulty:e.difficulty,category:e.category,isCancel:!1,id:e.id}})}))}))}))}))}}const F=_({addRequest:b.input(k).mutation((async({input:e})=>{const{difficulty:t,category:s,id:r}=e;if(await I.matchRequest.findFirst({where:{id:r}}).then((e=>e)))return{msg:"Request already exists",partner:"",isSuccess:!1};const n=new $;return await n.sendRequest({difficulty:t,category:s,id:r}).then((e=>e))})),cancelRequest:b.input(k).mutation((async({input:e})=>{const{difficulty:t,category:s,id:r}=e;return await Z(r,t,s),{msg:"Request cancelled",partner:"",isSuccess:!1}}))}),Z=async(e,t,s)=>await I.matchRequest.delete({where:{id:e,difficulty:t,category:s}}).catch((()=>{}));Promise.resolve(K().connect("amqp://localhost",((e,t)=>{if(e)throw e;t.createChannel(((e,t)=>{if(e)throw e;Promise.resolve(I.matchRequest.deleteMany({})),t.prefetch(1),console.log("[*] Waiting for requests.");const s="request_queue";t.assertQueue(s,{durable:!0}),t.consume(s,(e=>{if(!e)return;const s=e.properties.headers.difficulty,r=e.properties.headers.category,n=e.properties.headers.id,o=e.properties.replyTo;Promise.resolve(I.matchRequest.create({data:{id:n,replyTo:o,difficulty:s,category:r}})),console.log("[x] Received request: '%s'",n.toString()),t.ack(e),setTimeout((()=>{Promise.resolve(Z(n,s,r)).then((e=>{e&&t.sendToQueue(o,Buffer.from("Timeout. No match found."),{correlationId:n,headers:{isSuccess:!1}})}))}),3e4)}))}))})));const J=require("@aws-sdk/client-s3"),Y=require("@aws-sdk/s3-presigned-post"),ee=require("nanoid"),te=new J.S3Client({region:"us-east-1",endpoint:"http://localhost:9000",forcePathStyle:!0,credentials:{accessKeyId:"S3RVER",secretAccessKey:"S3RVER"}}),se=_({createPresignedUrl:b.query((async()=>{const e=(0,ee.nanoid)(8);return(0,Y.createPresignedPost)(te,{Bucket:S.S3_BUCKET_NAME,Key:e,Fields:{key:e},Conditions:[["starts-with","$Content-Type","image/"],["content-length-range",0,4e5]]})}))}),re=require("stream"),ne=require("@codemirror/state"),oe=require("@trpc/server/observable"),ie=t.z.object({codeSpaceId:t.z.string()}),ae=t.z.object({codeSpaceId:t.z.string()}),ce=t.z.object({codeSessionId:t.z.string()}),de=t.z.object({update:t.z.object({changes:t.z.string(),clientId:t.z.string()}),codeSessionId:t.z.string()}),ue=t.z.object({name:t.z.string()}),le=new Map,pe=new Map,Se=new Set;function ge(e){let t="";let s=0;for(;s<e;)t+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(62*Math.random())),s+=1;return t}async function me({codeSessionId:e,currentUserId:t}){const r=await I.codeSession.findUnique({where:{id:e}});if(!r)throw new s.TRPCError({code:"NOT_FOUND",message:"Session does not exist"});if(!await I.codeSessionUserAuth.findUnique({where:{codeSessionId_authorisedUserId:{codeSessionId:e,authorisedUserId:t}}})&&t!=r.userId)throw new s.TRPCError({code:"UNAUTHORIZED",message:"Unauthorised user"});return r}async function we(e){return pe.has(e)&&pe.delete(e),await I.codeSession.delete({where:{id:e}})}const fe=_({deleteCodeSpace:P.input(ae).mutation((async({ctx:e,input:{codeSpaceId:t}})=>{const r=e.session.user.id;if(!await I.codeSpace.findUnique({where:{id_userId:{id:t,userId:r}}}))throw new s.TRPCError({code:"BAD_REQUEST",message:"Code space does not exist"});const n=await I.codeSession.findUnique({where:{codeSpaceId_userId:{userId:r,codeSpaceId:t}}});return n&&await we(n.id),await I.codeSpace.delete({where:{id_userId:{id:t,userId:r}}}),{message:"Success"}})),createCodeSpace:P.input(ue).mutation((async({ctx:e,input:t})=>await I.codeSpace.create({data:{code:"",userId:e.session.user.id,name:t.name}}))),getAllSpaces:P.query((async({ctx:e})=>await I.codeSpace.findMany({where:{userId:e.session.user.id}}))),suscribeToSession:P.input(ce).subscription((async({ctx:e,input:t})=>{await me(Object.assign(Object.assign({},t),{currentUserId:e.session.user.id})),le.get(t.codeSessionId)||le.set(t.codeSessionId,new re.EventEmitter);const s=le.get(t.codeSessionId);return(0,oe.observable)((e=>{const t=t=>{e.next(t)};return s.on("onUpdate",t),()=>{s.off("onUpdate",t)}}))})),getClientId:P.query((()=>{let e=ge(15);for(;Se.has(e);)e=ge(15);return{clientId:e}})),deleteClientId:P.input(t.z.object({clientId:t.z.string()})).query((({input:e})=>{Se.has(e.clientId)&&Se.delete(e.clientId)})),createSession:P.input(ie).mutation((async({ctx:e,input:t})=>{const r={codeSpaceId:t.codeSpaceId,userId:e.session.user.id},n=await I.codeSpace.findUnique({where:{id_userId:{id:r.codeSpaceId,userId:r.userId}}});if(!n)throw new s.TRPCError({code:"BAD_REQUEST",message:"No such code space exists"});const o=await I.codeSession.findUnique({where:{codeSpaceId_userId:r}});if(o)return pe.set(null==o?void 0:o.id,ne.Text.of(n.code.split("\n"))),o;const i=await I.codeSession.create({data:r});return pe.set(null==i?void 0:i.id,ne.Text.of(n.code.split("\n"))),i})),getSession:P.input(t.z.object({codeSession:t.z.string()})).query((async({ctx:e,input:t})=>{var r,n;const o=await me({codeSessionId:t.codeSession,currentUserId:e.session.user.id});if(pe.has(t.codeSession))return{code:null!==(n=null===(r=pe.get(t.codeSession))||void 0===r?void 0:r.toString())&&void 0!==n?n:""};const i=await I.codeSpace.findUnique({where:{id_userId:{id:o.codeSpaceId,userId:o.userId}}});if(!i)throw new s.TRPCError({code:"INTERNAL_SERVER_ERROR",message:"Code space does not exist"});return pe.set(t.codeSession,ne.Text.of(i.code.split("\n"))),{code:i.code}})),updateSession:P.input(de).mutation((async({ctx:e,input:t})=>{const r=le.get(t.codeSessionId),n=ne.ChangeSet.fromJSON(JSON.parse(t.update.changes));null==r||r.emit("onUpdate",{changes:n.toJSON(),clientId:t.update.clientId});let o=pe.get(t.codeSessionId);if(!o){const e=await I.codeSession.findUnique({where:{id:t.codeSessionId}});if(!e)throw new s.TRPCError({message:"No such session exists",code:"BAD_REQUEST"});const r=await I.codeSpace.findUnique({where:{id_userId:{id:null==e?void 0:e.id,userId:null==e?void 0:e.userId}}});if(!r)throw new s.TRPCError({code:"BAD_REQUEST",message:"Failed to fetch code"});pe.set(t.codeSessionId,ne.Text.of(r.code.split("\n"))),o=pe.get(t.codeSessionId)}return pe.set(t.codeSessionId,n.apply(o)),{message:"Success"}})),saveSession:P.input(ce).query((async({ctx:e,input:t})=>{var r;await me({codeSessionId:t.codeSessionId,currentUserId:e.session.user.id});const n=await I.codeSession.findUnique({where:{id:t.codeSessionId}});if(!n)throw new s.TRPCError({code:"INTERNAL_SERVER_ERROR",message:"Code space does not exist"});return await I.codeSpace.update({where:{id_userId:{id:n.codeSpaceId,userId:e.session.user.id}},data:{code:null===(r=pe.get(t.codeSessionId))||void 0===r?void 0:r.toString()}}),{message:"Success"}})),deleteSession:P.input(ce).query((async({ctx:e,input:t})=>{await we(t.codeSessionId)}))}),he=_({matchRequest:F,question:C,form:se,user:Q,codeSession:fe}),ye=require("@trpc/server/adapters/ws"),Ee=require("http");var Ie=e.n(Ee);const Re=require("next");var ve=e.n(Re);const Oe=require("url"),Te=require("ws");var _e,be=e.n(Te);const Ue=parseInt(null!==(_e=process.env.PORT)&&void 0!==_e?_e:"3000",10);console.log(Ue);const qe=ve()({dev:!1}),Pe=qe.getRequestHandler();qe.prepare().then((()=>{var e;console.log("Preparing server");const t=Ie().createServer(((e,t)=>{var s;const r=e.headers["x-forwarded-proto"];if(r&&"http"===r)return t.writeHead(303,{location:"https://"+e.headers.host+(null!==(s=e.headers.url)&&void 0!==s?s:"")}),void t.end();const n=(0,Oe.parse)(e.url,!0);Pe(e,t,n)}));console.log("Created http server");const s=new(be().Server)({port:null!==(e=Number(S.NEXT_PUBLIC_WS_PORT))&&void 0!==e?e:3001}),r=(0,ye.applyWSSHandler)({wss:s,router:he,createContext:O});process.on("SIGTERM",(()=>{console.log("SIGTERM"),r.broadcastReconnectNotification()})),t.listen(Ue),console.log(`> Server listening at http://localhost:${Ue} as production`)})).catch((e=>{console.log(e)}))})();